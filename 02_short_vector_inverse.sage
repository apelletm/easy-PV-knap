########################################
## This file contains function that   ##
## compute a short vector in the      ##
## inverse ideal of I_Omega           ##
## (corresponding to some set Omega)  ##
########################################

load("01_KeyGen.sage")

#########################
## Some useful functions
#########################

## Compute the complementary of Omega
def complementary_Omega(Omega,m):
  Omega_c = []
  for j in range(m):
    if gcd(j,m) == 1 and not j in Omega:
      Omega_c += [j]
  return Omega_c
  
## Centered lift modulo q
def center_lift(w,q):
  res = ZZ(w)%q
  if res > q/2:
    res = res-q
  return res
  
## Extract the non-zero rows of a matrix
def extract_non_zero(M):
  list_M2 = []
  for i in range(M.nrows()):
    if vector(M[i]) != 0:
      list_M2 += [M[i]]
  M2 = Matrix(ZZ,list_M2)
  return M2
  

############################################
## Find the element with the largest order
## that stabilises a set Omega
############################################

def stabilize_Omega(i, Omega, m):
  Omega_red = [j%m for j in Omega] ## ensures that the elements of Omega are reduced mod m
  for j in Omega_red:
    if not (i*j)%m in Omega_red:
      return False
  return True
  
def max_order_stabilize(Omega, m):
  res = 0
  max_order = 0
  dic_orders = all_orders(m)
  for o in range(1,m+1):
    if o in dic_orders:
      for i in dic_orders[o]:
        if stabilize_Omega(i,Omega, m):
          res = i
          max_order = o
  if res == 0:
    print("Warning, no stablilizing element found for Omega")
  return [res,max_order]
  
def poly_to_vec(P,d):
  #transforms a polynomial P into a vector of dim d 
  #(coefficient vector padded with 0)
  v = vector(ZZ,d)
  vec_P = list(P)
  for i in range(len(vec_P)):
    v[i] = vec_P[i]
  return v
  
def poly_to_vec_center(P,d,q):
  #transforms a polynomial P into a vector of dim d 
  #(coefficient vector padded with 0) with integer coefficients centered around 0
  v = vector(ZZ,d)
  vec_P = list(P)
  for i in range(len(vec_P)):
    v[i] = center_lift(vec_P[i],q)
  return v
  
##########################################
## Computing the ideal I_Omega^{-1}
## (we actually compute 
## I_{\bar{Omega}} = q*I_Omega^{-1} )
## and its intersection with the field
## of smaller degree which stabilize it
##########################################

###################################################
## 1st method: slow but exact
## 1. compute the ideal I_{\bar{Omega}} in the
## field of large degree
## (this involves computation of an HNF in large
## dimension, which is the main cause of slowness)
## 2. compute the subspace corresponding to the
## subfield stabilizing Omega
## 3. intersect the ideal I_{\bar{Omega}} with
## the subfield (this provides a lattice of smaller
## dimension)
####################################################
  
def create_ideal_big_field(Omega, omega, q, m, verbose = True):
  ## This function creates the ideal in the big field associated to the set Omega
  ## For the attacks, this function will be called on the complementary of the set Omega
  ## (because we want a short vector in the inverse ideal)

  if verbose:
    print("\n1.Starting the computation of I_Omega in the big field")
  ## notations
  d = euler_phi(m)
  Fq = FiniteField(q)
  Poly_q = Fq['y']
  y = Poly_q.gen()
  Phi_q = Poly_q(cyclotomic_coeffs(m))
  
  ## Creating the product of all degree 1 polynomials in Omega
  P_Omega = Poly_q(1)
  for i in Omega:
    P_Omega = Poly_q(P_Omega*(y^i-omega))%Phi_q
  P_Omega = P_Omega%Phi_q ## I_Omega is generated by q and P_Omega
  
  ## Creating the basis of I
  list_M = []
  for k in range(d): ## add the rows corresponding to q
    list_M += [[0]*k+[q]*1+[0]*(d-k-1)]
  for k in range(d): ## add the rows corresponding to P_Omega
    list_M += [poly_to_vec((y^k*P_Omega)%Phi_q,d)]
    
  ## creating ideal
  M = Matrix(ZZ,list_M)
  if verbose:
    print("Computing the HNF in the big field, this may be slow...")
  MLLL = M.LLL() ##seems faster than echelon_form...
  if verbose:
    print("...HNF computed")
  M2 = extract_non_zero(MLLL) ## remove the rows with zero's
  if M2.nrows() != d:
    print("warning, the matrix M does not have d rows")
  elif abs(M2.det()) != q^(len(Omega)):
    print("warning, ideal I has not the good volume")
  if verbose:
    print("Now computing the object ideal (may also be slow, but less than the HNF)...")
  I = ZZ^d*M2
  if verbose:
    print("...Ideal created")
  return I
  
  
  
def subspace(Omega, m, verbose = True):
  ## Compute the subfield L of K fixed by the element of maximal order
  ## stabilizing Omega (i.e., the smallest subfield containing I_Omega)
  ## (again, we only consider cyclic subgroups of the Galois group
  ## for simplicity of implementation)
  
  if verbose:
    print("\n2. Creating a basis of the subfield fixing Omega")
    
  ## Notations
  d = euler_phi(m)
  PolyZZ = ZZ['x']
  Phi_m = PolyZZ(cyclotomic_coeffs(m))
    
  ## Compute an element of maximal order stabilizing I_Omega
  [i,max_o] = max_order_stabilize(Omega, m)
  if verbose:
    print("I_omega is stable by a subgroup of size: ", max_o)
    
  ## Create the matrix of constraints related to i_0
  list_M = []  
  for k in range(d):
    v = poly_to_vec(((PolyZZ.gen())^((i*k)%m))%Phi_m,d)
    v[k] = v[k]-1
    list_M += [v]
  M = matrix(QQ,list_M)
  H = M.kernel() ## H is the subspace corresponding to the subfield fixing I_Omega
  if dim(H)*max_o != d:
    print("Warning, H has not the good dimension")
    
  if verbose:
    print("The small field has dimension: ", dim(H))
  return H
  
  
  
def small_dim_ideal(Omega,omega, q, m, verbose = True):
  ## compute the ideal I associated to Omega
  ## and then intersect it with the subfield
  ## to obtain a (ideal) lattice of smaller dimension
  
  d = euler_phi(m)
  I = create_ideal_big_field(Omega, omega, q, m, verbose = verbose)
  H = subspace(Omega, m, verbose = verbose)
  if verbose:
    print("\n3. Intersecting the ideal with the subfield")
  I_small = I.intersection(H)
  M_I = matrix(ZZ,I_small.basis())
  if  RR((sqrt((M_I*M_I.transpose()).det()))^(1/dim(H))) > RR(sqrt(d/dim(H))*q^(len(Omega)/d)):
    print("warning: the reduced ideal I_small has a large volume")
  return M_I
  
##################################################################
## 2nd method: faster but might lead to an ideal slightly bigger
## Compute a 2 element representation of the ideal I_Omega
## (i.e., P and q such that I_Omega = <P,q>)
## such that both P and q live in the smaller field L
## Then compute I_Omega cap L directly in the subfield L as the 
## ideal generated by P and q (in L).
## This is an ideal that is contained in I_Omega cap L, but it 
## might be bigger. In order to have an ideal not much bigger,
## we can compute multiple elements P_i in I_Omega cap L instead
## of just one (optimal choice seems to be 2 elements P_1 and p_2)
###################################################################
  
def good_generators_ideal(Omega,omega,k, q, m, verbose = True):
  ## computes a list of <= k polynomials in H (subspace corresponding to L) 
  ## such that (g1,...,gk,q) generates the ideal associated to Omega
  
  if verbose:
    print("\n1.Computing ",k," generators of I_Omega that lie in L")
    
  ## notations
  d = euler_phi(m)
  Fq = FiniteField(q)
  Poly_q = Fq['y']
  y = Poly_q.gen()
  Phi_q = Poly_q(cyclotomic_coeffs(m))
  
  ## computing the generators
  gens = []
  for j in range(m):
    if gcd(j,m) == 1:
      P_Omega= Poly_q(1)
      for i in Omega:
        P_Omega = Poly_q(P_Omega*(y^(j*mod(i,m)^(-1))-omega^j))%Phi_q
      gens += [poly_to_vec_center(P_Omega,d,q)]
      if len(gens) == k:
        break
  return gens
  
def ideal_spanned(gens,H, q, m, verbose = True):
  ## gens = [g1,...,gk] are polynomial mod q such that (g1,...,gk,q) generates I_Omega
  ## compute the ideal generated by gens and q in H
  ## (i.e., the sublattice of I_Omega consisting in the intersection of I_Omega and H)
  ## It returns a generating set of the ideal, not a basis
  
  if verbose:
    print("\n3. Computing a generating set of I_Omega cap L")
  
  for w in gens:
    if w not in H:
      print("warning, one of the generator computed is not in H")
      
  ## notations
  d = euler_phi(m)
  Fq = FiniteField(q)
  Poly_q = Fq['y']
  Phi_q = Poly_q(cyclotomic_coeffs(m))
    
  # H is the sub-space corresponding to the subfield L
  # OH is the ring of integers of this subfield
  # (here we use the fact that for the large cyclotomic field K,
  # we had OK = ZZ^d, and so OH = H cap OK)
  OH = H.intersection(ZZ^d)
  
  # multiply gen and q by the basis vectors of OH to obtain
  # a generating set of the ideal spanned by gen and H
  list_M = []
  for v in Matrix(OH.basis()):
    f = Poly_q(list(v))
    
    #adding a vector corresponding to q*v
    tmp = poly_to_vec(f*q,d) 
    if not tmp in H:
      print("warning, an element of the reduced ideal is not in H")
    list_M += [tmp]
    
    #adding a vector corresponding to w*v for each w in gens
    for w in gens:
      g = Poly_q(list(w))
      tmp = poly_to_vec_center((f*g)%Phi_q,d,q) 
      if not tmp in H:
        print("warning, an element of the reduced ideal is not in H")
      list_M += [tmp]
  
  return Matrix(ZZ,list_M)
    

def small_dim_ideal_fast(Omega,omega,k, m, q, verbose = True):
  # computes a sub-lattice of the intersection of I and H
  # hopefully the sublattice is not too sparse 
  # and it runs faster than small_dim_ideal
  gens = good_generators_ideal(Omega,omega,k, q, m, verbose = verbose)
  H = subspace(Omega, m, verbose = verbose)
  M_I = ideal_spanned(gens,H, q, m, verbose = verbose)
  return M_I
  
#############################################
## Once the ideal of small dimension is
## computed, computes a short vector in it
## using the fpylll library
#############################################

from fpylll import IntegerMatrix, LLL, FPLLL, GSO
from fpylll import BKZ
  
## Computing a short basis of the lattice spanned by M
## (the lattice needs not be full rank, and it can have 
## more generators than a basis)
def reducing_basis(M, block_size = 10, auto_abort = True, max_hours = 1, float_type = 'NULL', precision = 60, save_result_in_file = False, output_file_name = 'NULL', verbose = True):
  # M is an integer matrix whose rows generate a lattice
  # if float_type is not provided, it will be estimated depending on the dimension
  # float_type has to be chosen among the possibilities for BKZ in fpylll
  # if float_type = 'mpfr', one also needs to specify the precision (used only in this case)
  A = IntegerMatrix.from_matrix(M)
  
  # LLL reduction first
  # (used to remove unnecessary rows)
  if verbose:
    print("\nStarting LLL reduction of a matrix of dimension ",A.nrows," by ", A.ncols)
  A_LLL = LLL.reduction(A)
  list_M = []
  for v in A_LLL:
    if vector(v) != 0:
      list_M += [v]
  A_LLL = IntegerMatrix.from_matrix(list_M)
  
  # BKZ reduction
  # computing parameters
  param = BKZ.Param(block_size = block_size, strategies = BKZ.DEFAULT_STRATEGY, auto_abort = auto_abort, max_time = ZZ(round(max_hours*3600)))

  # estimating required precision
  if float_type == 'NULL':
    dim = min(A.ncols, A.nrows)
    if dim <= 150:
      float_type = "default"
      precision = 60
    elif dim <= 220:
      float_type = "mpfr"
      precision = 60
    else:
      float_type = "mpfr"
      precision = 70
  
  if verbose:
    print("\nStarting BKZ reduction with:")
    print("lattice of dimension ",A_LLL.nrows," in ambiant space of dimension ",A_LLL.ncols)
    print("block size: ", block_size, ", auto_abort: ", auto_abort, ", max_hours: ", max_hours)
    if float_type == "mpfr":
      print("float_type: ", float_type, ", precision: ", precision)
    else:
      print("float_type: ", float_type)
  
  A_bkz = BKZ.reduction(A_LLL,param, float_type = float_type, precision = precision)
  
  if save_result_in_file: # print the reduced matrix in a file in case one wants to reuse it
    if output_file_name == 'NULL':
      output_name = "data/mat_"+str(A_bkz.ncols)+"_BKZ_"+str(block_size)+"_time_"+str(max_hours)+"h"
    else:
      output_name = output_file_name
    f = open(output_name, 'w')
    f.write(str(A_bkz))
    f.close()
  return Matrix(ZZ,A_bkz)
  
## Finding the shortest vector of a matrix
def best_vector(M, choice_norm = 2):
  best_norm = RR(vector(M[0]).norm(choice_norm))
  best_v = vector(M[0])
  for w in M:
    v = vector(w)
    if RR(v.norm(choice_norm)) < best_norm:
      best_norm = RR(v.norm(choice_norm))
      best_v = v
  return best_v
  
## Compute the ideal q*I_Omega^(-1) intersected with the optimal subfield
## then reduce the basis and outputs a short vector

def small_vector_I_Omega_inverse(Omega,omega,q,m,fast = True, k = 2, block_size = 10, auto_abort = True, max_hours = 1, float_type = 'NULL', precision = 60, save_result_in_file = False, verbose = True):

  # complementary of Omega so that we compute the inverse of ideal I_Omega
  Omega_c = complementary_Omega(Omega,m)
  
  # computing basis of I_Omega_c
  if fast:
    M = small_dim_ideal_fast(Omega_c,omega,k, m, q, verbose = verbose)
  else:
    M = small_dim_ideal(Omega_c,omega, q, m, verbose = verbose)
    
  #reducing the basis
  M_small = reducing_basis(M, block_size = block_size, auto_abort = auto_abort, max_hours = max_hours, float_type = float_type, precision = precision, save_result_in_file = save_result_in_file, verbose = verbose)
  
  #outputing the shortest vector
  v = best_vector(M_small)
  
  if verbose:
    d = euler_phi(m)
    expected_shortest = RR(q^((d-len(Omega))/d)*sqrt(d/(2*pi*e))) #expected length of a shortest vector in M_small
    print("\nExpected length of shortest vector: ", expected_shortest)
    print("Actual length of computed vector: ", RR(v.norm(2)))
    
  ## double checking that v is indeed in Omega_c
  poly_v = FiniteField(q)['y'](list(v))
  for i in Omega_c:
    if poly_v(omega^i) != 0:
      print("Warning, v is not zero on ", i, " which is in Omega_c")
    
  return v
  
  
